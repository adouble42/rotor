rotor uses a hybrid of NTRU public key encryption and the SHAKE-256 XOF function to encrypt your files. rotor uses a KDF based on yescrypt, using BLAKE-256, to generate a 64 byte key that is then expanded to 170 bytes with SHAKE-256, and hashed many times to result in a one time pad that the NTRU private key is XOR'd against, byte for byte.<br>
plaintext data is masked with SHAKE-256, the permutation function used by SHA-3 Keccak, which is on it's own an extremely useful XOF. using a randomly generated stream key, and encrypted, one block at a time, with NTRU. the final block of plaintext is padded to the full NTRU block size while being masked.<br>
it is my intention to expand the KDF further, to enable choice of hash function employed by the memory hardener, including expanding to 512 bit functions.<br>
the variant of BLAKE-256 is the original, full specification, not the BLAKE2s reduction. rotor is being designed for security first, efficiency not relevant. the goal is, output that is not just secure tomorrow, but decades from tomorrow.<br>
i don't believe files need to be opened on all devices. if you know you're sending something to someone with less capable hardware, use a lower cost parameter set, and reencrypt. but for things that require strong security, there's no reason i won't tax 45GB of RAM and 40% of the processor on my 12 core workstation that has 92GB of ram, to derive a key for things that are supposed to remain on my workstation. as schneier said, we can make it cost a hell of a lot to surveil us. for example, there's no reason i would encrypt a header key for a truecrypt volume with parameters that enable it to be decrypted by any thing other than it's host machine. unless i'm giving it to someone else, and then i'd reencrypt it using parameters appropriate for their environment.<br>
as a result, the default memory hardening parameters may require tuning. currently set, it takes about 8-9GB of RAM and 12 seconds for my workstation to derive a key, prior to expansion and further processing with SHAKE, which is an additional 12 seconds. this should make it pretty expensive for an attacker to design an FPGA or ASIC to attack, but also allow most modern machines to decrypt the output. i'm experimenting with different parameter sets, and an easier interface to select different ones for the end user is forthcoming.<br>
the key generator uses openwall passwdqc to check passwords for strength.<br>
rotor burns all security sensitive information literally as it is processed, in some cases, and immediately after use, in all cases. where it has been overwritten during processing, it is burned again after processing. an example of destruction during use, when XOR'ing values of byte arrays, after determining the result, the byte at both positions of the source arrays is overwritten to either an 'H' or an 'A', depending on whether it's an odd or even index, resulting in HAHAHAHAHAHAHAHA...and then afterwards, everything is burned before being unlocked.<br>
when burning or overwriting, we always process the maximum potential size of the object.<br>
rotor also uses mlockall() to lock it's entire current memory space on startup, after which, individual functions use mlock() to lock all sensitive data as it is updated. memory is only unlocked after being burned.<br>
this should prevent your keys from ever being swapped to disk.<br>
whether your operating system encrypts swap or not, is not trustworthy.<br>
it is my intention to compress the input file as it is being encrypted in order to lower the file size overhead of NTRU, which as used here, will inflate your files about 10x. this is a known factor you can avoid for now by simply using xz and compressing your plaintext prior to encrypting. i'm working on the integration presently, and it's taking some time because i'm putting a lot of thought in to exactly how i want to do it. while NTRU is expensive to use this way, it certainly gives us the sort of security margin i am looking for.<br>
<br>
thanks to the internet. except where otherwise required by individual authors, rotor is released under the simplified BSD 2 clause license, free for everyone. the more people using computationally expensive cryptography, the better.<br>
i'm not an expert, and i'll of course do everything in my power to make all revisions deemed necessary in the interest of security. this is experimental software and you use it at your own risk.<br>
to the key escrow set: key surrender, never. i hope your FPGAs cost a fortune, and burn like a dying red dwarf sun.<br>
mrn @ sdf<br>
and also<br><br>
#DicksOutForHarambe<br>